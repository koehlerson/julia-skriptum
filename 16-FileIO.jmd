```julia; echo=false; results="hidden"
using JuliaSkriptumKontrolle
temporary_directory = mktempdir()
current_workding_directory = pwd()
cd(temporary_directory)
mkdir("Ordner01")
touch("Datei01.txt")
touch("Datei02.txt")
touch(joinpath("Ordner01","Datei03.txt"))

open("Datei05.csv","w") do f
    write(f,"""
    time;temp;Status
    1;12,0;A
    2;13,1;A
    5; 9;B
    10;14;A""")
end
```

# Arbeiten mit Dateien und dem Dateisystem

Beim Automatisieren von Prozessen kommt es oft vor, dass große Dateimengen (z.B. Messwerte) eingelesen und verarbeitet werden müssen.
Dafür ist es notwendig, zum Einen die Dateien bzw. Dateinamen zu finden und zum Anderen benötigt man eine Möglichkeit Dateien einzulesen.

## Das Dateisystem

Julia bietet ein einheitliches Interface um auf das Dateisystem des Computers zuzugreifen.
Wird ein Juliaprozess ausgeführt läuft er in dem Verzeichnis in dem er gestartet wurde, dem sogenannten "working directory".
Anzeigen lässt sich dieses mit der Funktion `pwd` für "print working direcory".

```julia; term=true
pwd()
```

Die Funktion `readdir` gibt alle Dateien und Ordner eines Verzeichnisses aus.

```julia; term=true
readdir() # Standardmäßig wird das working directory verwendet
readdir("Ordner01")
```

Die Ausgabe von `readdir` besteht allerdings nur aus den Datei- oder Ordnernamen als `String`, es ist also nicht möglich zu erkennen, ob es sich um einen Ordner oder eine Datei handelt.
Dafür gibt es die Funktionen `isdir` und `isfile`.

```julia; term=true
isdir.(readdir()), isfile.(readdir())
```

Weitere praktische Funktionen, z.B. zum Verschieben und Löschen von Dateien sind in der Dokumentation unter [Base/Filesystem](https://docs.julialang.org/en/v1/base/file/) angeführt.

## Arbeiten mit Dateien

Beim Einlesen von Dateien kann grob in zwei Typen unterschieden werden:
- einfache Textdateien und
- Binärdateien.

Textdateien sind solche die mit einem simplen Editor geöffnet werden können und für die es nicht notwendig ist, die Daten vor der Verarbeitung zu Dekodieren. Klassische Formate sind csv, txt, tex, xml.

Eine solche Datei kann mit der Funktion `open` geöffnet werden. `open` erfordert neben der Angabe des Dateipfades, auch einen Modus.
Beim Umgang mit Dateien gibt es die folgenden Modi:
- `r` read: Die Datei wird nur gelesen.
- `w` write: Die Datei wird erzeugt (bzw. überschrieben falls sie vorhanden ist) und mit Daten gefüllt.
- `a` append: Die Datei wird um Daten erweitert.

```julia; term=true
f = open("Datei04.txt","w")
readdir()
```
`open` öffnet einen sogenannten Stream zu der Datei. Um nun Text in die neue Datei zu schreiben, muss dieser Text zuerst in den Stream geschrieben werden. Das ist mit dem `write` Befehl möglich. 

```julia; term=true
write(f,"Erste Zeile\n")
write(f,"Zweite Zeile")
```

Dadurch landen die Texte zuerst im Stream. Erst wenn der Stream mit `close` geschlossen wird, werden die Daten geschrieben.

```julia; term=true
close(f)
```

Das Pendant zu `write` ist die Funktion `read` die eine Datei vollständig mit einem angegeben Dateitypen einliest. Da es häufig vorkommt, dass eine Datei aufgeteilt in die einzelnen Zeilen benötigt wird gibt es noch die Funktion `readlines` die ein `String`-`Array` zurück gibt.

```julia; term=true
f = open("Datei04.txt","r")
read(f,String)
close(f)
f = open("Datei04.txt","r")
readlines(f)
close(f)
```

Generell sollten Streams immer mit `close` geschlossen werden wenn sie nicht mehr in Verwendung sind.

### Strukturierte Textdateien

Besonders häufig ist es notwendig Textdateien mit einer gewissen Struktur einzulesen.
Für sehr einfache Fälle mit homogenen Daten wie z.B. einer Zahlenmatrix, kann das in Julia enthaltene `DelimitedFiles`-Paket verwendet werden.

```julia; term=true
using DelimitedFiles
A = rand(2,2)
writedlm("MeineMatrix.txt",A)
isfile("MeineMatrix.txt")
f = open("MeineMatrix.txt","r")
readlines(f)
close(f)
B = readdlm("MeineMatrix.txt")
A == B
```

Weitere Optionen wie Angabe eines Trennzeichens sind in der Dokumentation unter [Standard Library/Delimited Files](https://docs.julialang.org/en/v1/stdlib/DelimitedFiles/index.html) zu finden.

Das `DelimitedFiles`-Paket stößt bei inhomogenen Daten, oder auch bei fehlenden Daten schnell an seine Grenzen.
Um ein stabiles Einlesen von solchen Dateien zu ermöglichen gibt es das `CSV`-Paket.
Das `CSV`-Paket biete eine Vielzahl von Optionen die es erlauben den Einlesevorgang genau an die gegebene Datei anzupassen.

Bei der folgenden Datei kann es sich um eine sehr übliche, bei einer Messung aufgezeichnete, Datei handeln.

```julia; term=true
f = open("Datei05.csv","r")
readlines(f)
close(f)
```

Es gibt eine Kopfzeile, verwendete Datentypen sind `Int`, `Float` und `String` und die `Float`-Zahlen sind anstelle eines Punktes mit einem Komma getrennt.

'readdlm' liest die Datei zwar ein, das Resultat ist aber noch nicht sinnvoll verwendbar:

```julia; term=true
readdlm("Datei05.csv")
```

Mit einem Blick in die Hilfe von `readdlm` können wir das Ergebnis durch Angeben des Trennzeichens mit `delim=';'` und Überspringen der Kopfzeile mit `skipstart=1` etwas verbessern.

```julia; term=true
readdlm("Datei05.csv",';',skipstart=1)
```

Um die Daten nun nutzbar zu machen, müssten noch die Kommas durch Punkte und die daraus resultierenden String in Zahlen umgewandelt werden.
Das Paket `CSV.jl` bietet für diesen Fall schon alle nötigen Optionen zum Einlesen:

```julia; term=true
using CSV, DataFrames
messwerte = DataFrame(CSV.File("Datei05.csv",delim=';',decimal=',',types=[Int,Float64,String]))
```

Durch das Konvertieren in einen `DataFrame` ist jetzt auch der Zugriff auf einzelne Werte sehr einfach möglich:

```julia; term=true
messwerte.temp, messwerte.Status
```

Ein `DataFrame` ist ein Datentyp der besonders für die Verarbeitung von tabellarischen Daten geeignet ist.
Nähere Details zu [DataFrames](https://juliadata.github.io/DataFrames.jl/stable/)[^1] und [CSV.jl](https://juliadata.github.io/CSV.jl/stable/)[^2] können der jeweiligen Dokumentation entnommen werden.

[^1]: <https://juliadata.github.io/DataFrames.jl/stable/>
[^2]: <https://juliadata.github.io/CSV.jl/stable/>

## Aufgaben

Die Aufgaben für dieses Beispiel basieren alle auf dem selben Datensatz.
In den Beispielen geht es darum, als Manager eines [Prepper-Camps](https://de.wikipedia.org/wiki/Prepper)[^3], das aus mehreren Lagern besteht, den Überblick über den Lagerbestand zu behalten.
Für jedes Lager wird eine Liste mit Ein- und Ausgängen geführt:

```
Artikel,Bestand
Batterie,5
Reis,10
Fernglas,5
Taschenmesser,38
Konserven,28
Konserven,-23
Batterie,29
Fernglas,-2
Fernglas,-1
```

Im Kontrollprogramm ist für das erstellen von Testdatensätzen die Funktion 

```julia; term=true
JuliaSkriptumKontrolle.setup("15.3")
```

definiert.
Nach dem Aufruf wird im aktuellen Verzeichnis ein neuer Ordner `15-3` erstellt.

```julia; term=true
readdir("15-3")
```

In dem Ordner befinden sich die Bestandslisten für alle Lager.
Die Lager sind immer nach dem Schema `Lager[id].csv` benannt.
Der Code soll in allen Prepper-Camps verwendet werden können, d.h. die Anzahl an Dateien kann sich immer ändern und da alle Camps verschieden Betriebssysteme verwenden muss immer `joinpath` beim verketten von Pfaden verwendet werden:

```julia
joinpath("15-3","Lager1.csv")
```

Wie im Abschnitt Interaktion erwähnt, sind die Trennzeichen bei Pfaden je nach Betriebssystem verschieden.
Da das zu einigen Problemen führen kann, gibt es die Funktion `joinpath` die das richtige Trennzeichen wählt.

[^3]: <https://de.wikipedia.org/wiki/Prepper>

### Bestandsermittlung Lager

Es wird eine Funktion benötigt die den Bestand jedes Gegenstands pro Lager ermittelt (Summe der Ein- und Ausgänge).
Die Funktion soll ein `Dict` mit der Zuordnung `Lager id => Bestand` zurückgeben, wobei `Bestand` wieder ein `Dict` mit der Zuordnung `Artikel => Anzahl` ist.

```julia; results="hidden"; echo=false;
function read_lagers()
    path = "15-3"
    files = readdir(path)
    Dict(map([f=>DataFrame(CSV.File(joinpath(path,f))) for f in files]) do p
         dfl = p.second
         bestand = Dict{String,Int}()
         for row in eachrow(dfl)
         (row.Artikel in keys(bestand)) || (bestand[row.Artikel] = 0)
         bestand[row.Artikel] += row.Bestand
         end
         return parse(Int,p.first[6:end-4])=>bestand
         end)
end
```

Beispiele:
```julia; term=true
bestand = read_lagers();
typeof(bestand)
bestand[1]
bestand[3]
```

### Bestand suchen

Es soll eine Funktion geschrieben werden, die in allen Lagern nach einem Gegenstand `X` sucht, von dem noch mindestens `n` Stück vorhanden sind.
Ausgabe der Funktion ist ein `Int`-Array mit den ids der Lager.
Wird kein Lager gefunden, soll ein leeres Array ausgegeben werden.
Als Basis soll die Funktion aus der ersten Aufgabe `read_lagers` herangezogen werden.
Für die Kontrolle muss die Funktion dann in den Kontrollblock kopiert werden:

```julia; eval=false
@Aufgabe "15.3.2" begin
    # using ...
    function read_lagers()
        # code ...
    end
    function lager_mit(artikel,stückzahl)
        # code ...
    end
end
```

```julia; results="hidden"; echo=false;
function lager_mit(artikel,anzahl)
    lagers = read_lagers()
    l_ids = Int[]
    for i in keys(lagers)
        l = lagers[i]
        if artikel in keys(l) && l[artikel] >= anzahl
            push!(l_ids,i)
        end
    end
    return l_ids
end
```

Beispiele:
```julia; term=true
lager_mit("Taschenlampe",4)
lager_mit("Reis",30)
```

### Gesamtbestand

Es soll eine Funktion geschrieben werden, die den Bestand des gesamten Camps ermittelt.
Die Ausgabe soll wie bei der ersten Aufgabe als `Dict` erfolgen.
Als Basis soll wieder die Funktion aus der ersten Aufgabe verwendet werden.

```julia; results="hidden"; echo=false;
function gesamt_bestand()
    lagers = read_lagers()
    bestand = Dict{String,Int}()
    for i in keys(lagers)
        l = lagers[i]
        for k in keys(l)
            (k in keys(bestand)) || (bestand[k] = 0)
            bestand[k] += l[k]
        end
    end
    return bestand
end
```

Beispiele:
```julia; term=true
gesamt_bestand()
```

<!-- Wechsel zurück ins richtige WD -->
```julia; echo=false
cd(current_workding_directory)
```

