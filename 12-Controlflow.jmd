# Kontrollstruktur

Der Code in den bisher behandelten Beispiele setzte sich aus einer sich nicht verzweigenden Verkettung von Befehlen zusammen.
Für sehr rudimentäre Programme mag das ausreichen, in den meisten Fällen werden aber Verzweigungen in Form von `if`-Bedingungen und Schleifen benötigt.

## Verzweigungen

Dieses Konstrukt erlaubt es, abhängig von einer *Bedingung* (die ausgewertet vom Typ `Bool` sein muss) einen Codeteil auszuführen oder zu überspringen.
Die einfachste Form ist das `if`-Statement:

```julia;
x = -1
if x < 0
    println("x ist negativ.")
end
```

In diesem Beispiel ist die *Bedingung* `x > 0`. Wie bereits im Abschnitt zu den Datentypen gezeigt, ergibt die Auswertung dieses Ausdrucks einen Wert vom Typ `Bool`:

```julia; term=true
x < 0
typeof(x < 0)
```

Die zweite Form ist die Kombination aus `if` und `else`. `else` bezeichnet den Zweig der ausgeführt wird, falls die Bedingung nicht erfüllt ist.

```julia;
x = 1
if x < 0
    println("x ist negativ.")
else
    println("x ist positiv.")
end
```

Da `x < 0` ausgewertet `j x < 0` ergibt, wird der `if`-Zweig übersprungen und der `else`-Zweig ausgeführt.

Die dritte Form ist im Grunde eine vereinfachte Schreibweise für Kombinationen von Form eins und Form zwei.
Der folgende Code 

```julia;
x = 9
if x < 0
    println("x ist negativ.")
else
    if x <= 10 
        println("x ist eine Zahl von 0 bis 10.")
    else
        println("x ist größer als 10.")
    end
end
```

kann einfacher und übersichtlicher durch `elseif` geschrieben werden.

```julia;
x = 9
if x < 0
    println("x ist negativ.")
elseif x <= 10 
    println("x ist eine Zahl von 0 bis 10.")
else
    println("x ist größer als 10.")
end
```

## Schleifen

Computer sind besonders gut geeignet um repetitive Aufgaben zu lösen.
Solche Aufgaben werden durch Schleifen definiert.
Julia biete zwei Arten von Schleifen: `for` und `while`-Schleife.

Die `while`-Schleife hat eine gewisse Ähnlichkeit zur `if`-Bedingung.
Eine Aufgabe in einer solchen Schleife wir solange ausgeführt, solange eine *Bedingung* erfüllt ist.

Im folgenden Beispiel wird jede Zahl von 0 bis 10 ausgegeben (`global i` kann für das Erste ignoriert werden)

```julia; hold=true
function zähle_bis(n)
    i = 1
    while i <= n
        println("Bin bei Zahl $i")
        i += 1
    end
end
zähle_bis(10)
```

Der Code wird wird folgendermaßen durchschritten:
1. Initialisiere `i` mit `1`
2. Falls die Bedingung `i <= 10` erfüllt ist gehe zu (3), ansonsten gehe zu (6)
3. Ausgabe von `"Bin bei Zahl $i"`
4. Erhöhe `i` um `1`
5. Gehe zurück zu (2)
6. Ende

Dieser Ablauf wird Schleife genannt, weil (5) wieder zurück zu (2) springt.
Bei diesem Code ist Vorsicht geboten: Vergisst man die Zeile `i += 1`, wird die Bedingung `i <= 10` nie erfüllt.
Das bedeutet die Schleife läuft endlos (Endlosschleife). 
In der REPL oder in Juno kann eine Endlosschleife durch die Tastenkombination `Ctrl-C` abgebrochen werden.

Beim obigen Beispiel handelt es sich um eine Zählschleife.
Dieses Konstrukt ist so häufig, dass es einen eigenen Schleifentyp dafür gibt: Die `for`-Schleife.
Der Code in der `for`-Schleife wird für jedes Element in einer ihr übergebenen Menge ausgeführt.
Das vorherige Beispiel vereinfacht sich daher zu:

```julia
function zähle_bis(n)
    for i in 1:n
        println("Bin bei Zahl $i")
    end
end
zähle_bis(10)
```

Anstelle von `1:n` kann jede Art von Liste angegeben werden.

```julia
for buchstabe in ["A", "B", "C", "D"]
    println("Bin bei Buchstabe $buchstabe")
end
```

### break und continue

Eine Schleifeniteration kann jederzeit durch den Aufruf von `break` abgebrochen und den Aufruf von `continue` übersprungen werden.

Im folgenden Beispiel werden von einem `String` nur die Vokale gesammelt. Falls ein `!` gefunden wird, werden die gesammelten Vokale ausgegeben und die Schleife beendet.

```julia
function sammle_vokale(text)
    vokale_sammlung = ""
    for buchstabe in text
        if buchstabe == '!'
            println(vokale_sammlung)
            break
        end
        if !(buchstabe in ('a','e','i','o','u'))
            continue
        end
        vokale_sammlung *= buchstabe
    end
end
sammle_vokale("Finde die Vokale in diesem Satz. Gehe aber nicht weiter als bis zum !. Das sollst du nicht mehr ansehen")
```

`break` wird oft auch in Kombination mit `while`-Schleifen verwendet die endlos laufen. 
Wenn Beispielsweise in der Schleife auf eine Dateneingabe gewartet wird, oder die Abbruchbedingung sehr komplex ist.
In diesem Fall kann eine Endlosschleife absichtlich durch Verwenden der Bedingung `true` konstruiert werden.

### Performance Optimierung Julia

Bei den folgenden Aufgaben wird es wichtig sein, einen möglichst effizienten Code zu schreiben.
Optimierung ist ein sehr komplexes Thema, es gibt in Julia aber ein paar grundlegende Punkte die beachtet werden sollten.

Um eine Auskunft über die Laufzeit eines Codes zu erhalten (Benchmark-Test) biete Julia das `@time`-Macro.

Die folgende Funktion berechnet `n`-mal die inverse einer Matrix `A` und ist nur als Beispielfunktion für die Verwendung von `@time` gedacht.

```julia
function time_dummy(n::Int)
    A = [3 1 0
         0 1 0
         3 3 3]
    for i in 1:n
        inv(A)
    end
end
```

```julia; term=true
@time time_dummy(100000)
@time time_dummy(100000)
@time time_dummy(100000)
```

Das `@time`-Macro gibt die erforderliche Zeit und Angaben über das Speichermanagement aus.
Der erste Aufruf der neu geschriebenen Funktion `time_dummy` braucht wesentlich länger als die nächsten beiden.
Das liegt daran, dass Julia beim ersten Aufruf die Funktion für die angegeben Argumente kompiliert.

Dieser Vorgang ist sehr wichtig um eine performante Ausführung zu ermöglichen und wird stark durch die so genannte *Typenstabilität* beeinflusst.

#### Typenstabilität

Stabilität bedeutet hier, dass sich der Datentyp einer Variable mit der Laufzeit nicht ändert.
Eine mögliche Fehlerquelle dafür ist im folgendem Beispiel zu sehen[^1].

[^1]: <http://www.johnmyleswhite.com/notebook/2013/12/06/writing-type-stable-code-in-julia/>

```julia
function summe_sin_A(n::Int)
    ∑ = 0
    for i in 1:n
        ∑ += sin(n)
    end
    return ∑
end

function summe_sin_B(n::Int)
    ∑ = 0.0
    for i in 1:n
        ∑ += sin(n)
    end
    return ∑
end
```

Der einzige Unterschied der Funktionen A und B befindet sich in der ersten Zeile bei der Definition von `\sum`. Im Fall von A wird mit `Int` im Fall von B mit `Float64` initialisiert.

Um die Funktionen zu Benchmarken werden beide in Schleifen ausgeführt.

```julia; results="hidden"
function benchmark_summe_A()
    for _ in 1:100
        summe_sin_A(100000)
    end
end

function benchmark_summe_B()
    for _ in 1:100
        summe_sin_B(100000)
    end
end
```

Die Laufzeit der beiden Fälle ergibt sich zu:

```julia;term=true
benchmark_summe_A(); benchmark_summe_B(); # Erster Aufruf zum kompilieren
@time benchmark_summe_A()
@time benchmark_summe_B()
```

Der große Unterschied zwischen den beiden Funktionen resultiert aus dem Rückgabewert der Funktion `sin`:
```julia; term=true
typeof(sin(3))
```

`sin` gibt `Float64` zurück. Das bedeutet bei Fall A muss `\sum` von `Int` in `Float64` konvertiert werden, was immens viel Zeit benötigt.

Ein weiterer häufig gemachter Fehler tritt bei Funktionen auf, die für gleiche Datentypen der Argumente verschiedene Datentypen der Ergebnisse zurückgeben.
Beispielsweise gibt die folgende Definition der Rampen-Funktion inkonsistente Datentypen zurück:

```julia; results="hidden"
function ramp(x)
    if x < 0
        return 0
    else
        return x
    end
end
```

```julia; term=true
ramp(3.0)
ramp(-3.0)
ramp(3)
ramp(-3)
```

Eine Möglichkeit wäre die Funktion für die Typen `Float64` und `Int` zu spezialisieren oder besser die `zero` Funktion zu verwenden:

```julia; results="hidden"
function ramp(x)
    if x < 0
        return zero(x)
    else
        return x
    end
end
```

```julia; term=true
ramp(3.0)
ramp(-3.0)
ramp(3)
ramp(-3)
```

#### Vermeiden von globalen Variablen

Eine globale Variable ist beispielsweise `x` im folgenden Code:

```julia

x = "Ich bin global!"

function test_global()
    println(x)
end
test_global()
```

`x` ist innerhalb der Funktion `test_global` verwendbar obwohl die Variable außerhalb definiert wurde.
Der Nachteil von globalen Variablen ist, das Julia die Funktionen die die Variablen verwenden wieder nicht exakt für den Typ
der globalen Variable spezialisieren kann, da die Variable veränderbar ist:

```julia
x = 100
test_global()
```

`test_global` gibt jetzt den neuen Wert von `x` aus. In diesem Fall hat sich nicht nur der Wert, sonder auch der Typ von `String` zu `Int` geändert.

In manchen Fällen ist es sinnvoll globale Variablen zu verwenden, dann sollten diese mit dem Keyword `const` als Konstanten definiert werden (Konstanten werden üblicherweise in Blockbuchstaben geschrieben).

```julia
const GRAV_BESCHL = 9.81 # m/s²
function Kraft(masse) # masse in kg
    masse*GRAV_BESCHL
end
Kraft(8.0)
```

Eine Konstante darf sich nicht ändern, damit ist der Code wieder Typenstabil.

```julia
GRAV_BESCHL = "Neuer Wert"
```

## Aufgaben

### Schreibe ein Funktion die Gerade oder Ungerade für eine Zahl ausgibt

```julia
function gerade_ungerade(x::Int)
    if x % 2 == 0
        println("Gerade")
    else
        println("Ungerade")
    end
end
```

```julia; term=true
gerade_ungerade(11)
gerade_ungerade(218)
```

### Schreibe ein Skript das eine Ziffer einliest und diese in Worten darstellt.

Definiere dafür zuerst eine Funktion die für den Benutzer "{}Ziffer eingeben: "{} anzeigt und dann auf die Eingabe wartet.
Die Ausgabe eines Textes ohne Zeilenumbruch ist mit `print` möglich. Ein `String` kann durch die Funktion `readline` eingelesen werden.
Das Skript soll von der *Commandline* wie folgt ausgeführt werden:

```bash
julia ziffer_bezeichnung.jl
Ziffer eingeben: 3
Drei

julia ziffer_bezeichnung.jl
Ziffer eingeben: 10
Falsche Eingabe. Es werden nur einzelne Ziffern unterstützt.
```

### Skript Flächeninhalt

Schreibe ein Skript das den Benutzer dazu auffordert den Radius eines Kreises einzugeben und nach der Eingabe den Flächeninhalt und den Umfang ausgibt. Beide Ergebnisse sollen auf zwei Dezimalstellen gerundet werden.
Das Skript soll von der *Commandline* wie folgt ausgeführt werden:

```bash
julia kreis.jl
Radius eingeben: 3
A = 28.27
U = 18.85

julia kreis.jl
Radius eingeben: abc
Falsche Eingabe.
```

### Skript Flächeninhalt mehrmalige Eingabe

Erweitere das Skript zur Berechnung des Flächeninhalts des Kreises so, dass der Benutzer nach einer Eingabe gleich eine weitere Eingabe machen kann.
Das Skript soll erst abgebrochen werden, wenn eine leere Eingabe gemacht wird.

```bash
julia kreis.jl
Radius eingeben: 3
A = 28.27
U = 18.85

Radius eingeben: abc
Falsche Eingabe.

Radius eingeben: 1.2
A = 4.52
U = 7.54

Radius eingeben:
Programm Beendet!
```

### Berechne PI mittels Monte-Carlo-Simulation
### Integriere eine Beliebige Funktion nummerisch
Simpson und / oder trapezoid

Simpson:
```julia
function ∫(f::Function, a::Number, b::Number, n::Number)
    n % 2 == 0 || error("`n` must be even")
    h = (b-a)/n
    s = f(a) + f(b)
    s += 4*mapreduce(f,+,a .+ (1:2:n) * h)
    s += 2*mapreduce(f,+,a .+ (2:2:n-1) * h)
    return h/3 * s
end
```

### Wie hoch ist die Wahrscheinlichkeit
... mit einem idealen Würfel (1-6) 3 x hintereinander 4 zu würfeln

```{julia;}
throw() = rand(1:6)
@time P_est = sum([all(i->i==4,(throw() for _ in 1:3)) for __ in 1:100000000])/100000000
P_corr = 1/6^3
@show P_est, P_corr
```

... mit einem idealen Würfel (1-6) bei 3 Würfen mindestens 1nen 4er zu würfeln

```{julia;}
@time P_est = sum([any(i->i==4,(throw() for _ in 1:3)) for __ in 1:100000000])/100000000
P_corr = (1/6+5/6*1/6+5/6*5/6*1/6)
@show P_est, P_corr
```
