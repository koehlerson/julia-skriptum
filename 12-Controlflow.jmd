# Kontrollstruktur

Der Code in den bisher behandelten Beispiele setzte sich aus einer sich nicht verzweigenden Verkettung von Befehlen zusammen.
Für sehr rudimentäre Programme mag das ausreichen, in den meisten Fällen werden aber Verzweigungen in Form von `if`-Bedingungen und Schleifen benötigt.

## Verzweigungen

Dieses Konstrukt erlaubt es, abhängig von einer *Bedingung* (die ausgewertet vom Typ `Bool` sein muss) einen Codeteil auszuführen oder zu überspringen.
Die einfachste Form ist das `if`-Statement:

```julia;
x = -1
if x < 0
    println("x ist negativ.")
end
```

In diesem Beispiel ist die *Bedingung* `x > 0`. Wie bereits im Abschnitt zu den Datentypen gezeigt, ergibt die Auswertung dieses Ausdrucks einen Wert vom Typ `Bool`:

```julia; term=true
x < 0
typeof(x < 0)
```

Die zweite Form ist die Kombination aus `if` und `else`. `else` bezeichnet den Zweig der ausgeführt wird, falls die Bedingung nicht erfüllt ist.

```julia;
x = 1
if x < 0
    println("x ist negativ.")
else
    println("x ist positiv.")
end
```

Da `x < 0` ausgewertet `j x < 0` ergibt, wird der `if`-Zweig übersprungen und der `else`-Zweig ausgeführt.

Die dritte Form ist im Grunde eine vereinfachte Schreibweise für Kombinationen von Form eins und Form zwei.
Der folgende Code 

```julia;
x = 9
if x < 0
    println("x ist negativ.")
else
    if x <= 10 
        println("x ist eine Zahl von 0 bis 10.")
    else
        println("x ist größer als 10.")
    end
end
```

kann einfacher und übersichtlicher durch `elseif` geschrieben werden.

```julia;
x = 9
if x < 0
    println("x ist negativ.")
elseif x <= 10 
    println("x ist eine Zahl von 0 bis 10.")
else
    println("x ist größer als 10.")
end
```


### Aufgabe: Schreibe ein Funktion die Gerade oder Ungerade für eine Zahl ausgiebt

```julia
function gerade_ungerade(x::Int)
    if x % 2 == 0
        println("Gerade")
    else
        println("Ungerade")
    end
end
```

```julia; term=true
gerade_ungerade(11)
gerade_ungerade(218)
```

### Aufgabe: Schreibe ein Skript das eine Ziffer einliest und diese in Worten darstellt.

Definiere dafür zuerst eine Funktion die für den Benutzer "{}Ziffer eingeben: "{} anzeigt und dann auf die Eingabe wartet.
Die Ausgabe eines Textes ohne Zeilenumbruch ist mit `print` möglich. Ein `String` kann durch die Funktion `readline` eingelesen werden.
Das Skript soll von der *Commandline* wie folgt ausgeführt werden:

```bash
julia ziffer_bezeichnung.jl
Ziffer eingeben: 3
Drei

julia ziffer_bezeichnung.jl
Ziffer eingeben: 10
Falsche Eingabe. Es werden nur einzelne Ziffern unterstützt.
```

## Schleifen for, while


### Performance Optimierung Julia
#### Macros @time, Benchmarktools 
### Aufgabe: Berechne PI mittels Monte-Carlo-Simulation
### Aufgabe: Integriere eine Beliebige Funktion nummerisch
Simpson und / oder trapezoid

Simpson:
```julia
function ∫(f::Function, a::Number, b::Number, n::Number)
    n % 2 == 0 || error("`n` must be even")
    h = (b-a)/n
    s = f(a) + f(b)
    s += 4*mapreduce(f,+,a .+ (1:2:n) * h)
    s += 2*mapreduce(f,+,a .+ (2:2:n-1) * h)
    return h/3 * s
end
```

### Aufgabe: Wie hoch ist die Wahrscheinlichkeit
... mit einem idealen Würfel (1-6) 3 x hintereinander 4 zu würfeln

```{julia;}
throw() = rand(1:6)
@time P_est = sum([all(i->i==4,(throw() for _ in 1:3)) for __ in 1:100000000])/100000000
P_corr = 1/6^3
@show P_est, P_corr
```

... mit einem idealen Würfel (1-6) bei 3 Würfen mindestens 1nen 4er zu würfeln

```{julia;}
@time P_est = sum([any(i->i==4,(throw() for _ in 1:3)) for __ in 1:100000000])/100000000
P_corr = (1/6+5/6*1/6+5/6*5/6*1/6)
@show P_est, P_corr
```
