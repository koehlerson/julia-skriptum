# Arrays, Tuple, Set, Dict
Dieses Kapitel beinhaltet einige wichtige Typen in Julia, die mehrere Werte aufnehmen können.
## Arrays
Wie ein *String* ist ein *Array* eine geordnete Abfolge von Werten.
Während ein String aus Werte vom Typ *Char* besteht, können Arrays Werte aller möglichen Typen enthalten.
Die Werte innerhalb eines Arrays heißen *Elemente*.

Arrays können auf verschiedenste Weisen erzeugt werden.
Alle Elemente getrennt durch `,` innerhalb von eckigen Klammer zu schreiben ist die einfachste Variante:
```julia
primes = [2, 3, 5, 7, 11, 13]
baustoffe = ["Holz", "Beton", "Stahl"]
```

Die erste Zeile erzeugt ein Array aus sechs Int-Zahlen, die zweite Zeile erzeugt ein Array aus drei Strings.
Die Elemente eines Arrays müssen aber nicht vom gleichen Typ sein; sogar Arrays innerhalb von Arrays sind möglich:
```julia
stahl = ["S235", 235.0, [10, 20]]
```
Mit `typeof()` kann der Typ eines Arrays abgefragt werden:
```julia; term=true
typeof(primes)
typeof(baustoffe)
typeof(stahl)
```
Innerhalb der geschwungenen Klammer steht dabei zuerst, von welchem Typ die Werte des Arrays sind und an zweiter Stelle, welche Dimension das Array hat.
Ein *leeres Array* hat keine Elemente und kann zum Beispiel mit leeren, eckigen Klammern (`[]`) erzeugt werden.
Das so erzeugte leere Array ist dabei vom Typ `Array{Any,1}`.
Ein leeres Array mit Werten eines bestimmten Typs, wie zum Beispiel `Float64`, kann mittels `Array{Float64,1}()` oder `Float64[]` erzeugt werden:
```julia; term=true
[]
Array{Float64,1}()
Float64[]
```

Mit der Schreibweise `Float64[]` können allerdings nur eindimensionale Arrays erzeugt werden.

### Arrays sind veränderbar
Die Syntax für den Zugriff auf ein bestimmtes Element eines Arrays ist dieselbe wie beim Zugriff auf einen Character innerhalb eines Strings: das Array, direkt gefolgt von einer Int-Zahl als Index innerhalb eckiger Klammern.
```julia; term=true
baustoffe[2]
```

Wie bei Strings kann auch auf Teile eines Arrays zugegriffen werden:
```julia; term=true
primes[2:4]
primes[3:end]
```

Anders als Strings sind Arrays allerdings veränderbar.
Das heißt, einzelne Elemente eines Arrays können durch den `=`-Operator neu zugewiesen werden.
Der zugewiesenen Datentyp muss mit dem Typen des Arrays übereinstimmern.
```julia; term=true
baustoffe[3] = "Ziegel"
baustoffe[2] = 2
print(baustoffe)
```

Folgendes Verhalten kann dabei möglicherweise zu Verwirrung führen:
```julia; term=true
a = [1, 4, 3]
b = a
b[2] = 2
@show a b;
```
Verändern eines Wertes im Array `b` verändert also auch den Array `a`.
Das liegt daran, dass der Ausdruck `b = a` den Array `a` **nicht** kopiert, sondern auf ihn verweist.
Zum Kopieren eines Arrays eignet sich die Funktion `copy()`.
```julia; term=true
a = [1, 4, 3]
b = copy(a)
b[2] = 2
@show a b;
```

### Funktionen der Array Library
`length` gibt die Anzahl der Elemente eines Arrays zurück.
Ein Array innerhalb eines Arrays ist dabei ein Element.
```julia; term=true
length(primes)
length(stahl)
length(stahl[3])
```

`push!` fügt ein neues Element am Ende des Arrays ein:
```julia; term=true
fib = [1, 1, 2, 3, 5];
push!(fib, 8);
@show fib
```

`append!` hängt einen Array am Ende des Arrays an:
```julia; term=true
append!(fib, [13, 21, 34]);
@show fib
```

`insert!` fügt ein Element bei einem bestimmten Idex in das Array ein:
```julia; term=true
countdown = [5, 4, 3, 1, 0];
insert!(countdown, 4, 2)  # Die Zahl 2 wird an vierter Stelle eingefügt
```

`sort!` sortiert die Elemente eines Ararys vom niedrigsten zum höchsten Wert:
```julia; term=true
c = ['d', 'g', 'a', 'w', 'f'];
sort!(c);
@show c
```

`sort` hingegen erzeugt eine sortierte Kopie des Arrays:
```julia; term=true
c1 = ['d', 'g', 'a', 'w', 'f'];
c2 = sort(c1);
@show c1 c2
```

Generell hat sich in Julia etabliert, dass Funktionen, die direkt ihr Argument verändern mit `!` enden.

### Elemente löschen
Es gibt verschiedene Möglichkeiten einzelne Elemente aus einem Array zu löschen.
`pop!` entfernt das letzte Element aus dem Array und gibt dieses Element zurück:
```julia; term=true
a = ['a', 'b', 'c'];
pop!(a)
@show a
```

Das erste Element eines Arrays kann mittels `popfirst!` entfernt werden:
```julia; term=true
a = ['a', 'b', 'c'];
popfirst!(a)
@show a
```

Ist der Index des zu entfernenden Elements bekannt, kann dieses mit `splice!` aus dem Array gelöscht werden:
```julia; term=true
a = ['a', 'b', 'c'];
splice!(a, 2)
@show a
```

Ähnlich funktioniert auch `deleteat!`.
Der Unterschied ist dabei, dass nicht das entfernte Element, sondern das Array zurückgegeben wird:
´´´julia; term=true
a = ['a', 'b', 'c'];
deleteat!(a,2)
@show a
```

### Strings und Arrays
Strings und Arrays sind in manchen Punkten sehr ähnlich.
Ein String ist eine Abfolge von Characters und da ein Array mit beliebigen Datentypen befüllt werden kann, ist ein Array aus Characters auch eine Abfolge von Characters.
Trotzdem sind beides verschiedene Typen mit unterschiedlichen Eigenschaften.
`collect` konvertiert einen String in ein Array von Characters:
```julia; term=true
a = collect("spam");
print(a)
```

Mittels `split` kann ein String entlang bestimmter Zeichen in mehrere Teile getrennt werden.
So können beispielsweise Sätze in einzelne Worte aufgeteilt werden:
```julia; term=true
s1 = split("Julia ist großartig");  # Standardmäßig wird bei jedem Leerzeichen getrennt
print(s1)
s2 = split("Stahl;Beton;Ziegel;Holz",';');  # Als zweites Argument kann das Trennzeichen festgelegt werden
print(s2)
```

`join` verbindet ein Array aus Strings zu einem einzelnen String:
```julia; term=true
s1 = split("julia ist großartig");
sort!(s1);
s2 = join(s1,' ');
print(s2)
```

### Mehrdimensionale Arrays
In vielen numerischen Aufgaben sind zwei- oder mehrdimensionale Arrays hilfreich.
In Julia wird ein zweidimensionales Array auch als *Matrix* bezeichnet.
Die eingabe erfolgt wie bei eindimensionalen Arrays in eckigen Klammern, allerdings werden die Elemente zeilenweise mit Leerzeichen zwischen den Elementen einer Zeile und Semikola zwischen den Zeilen eingegeben.
Alternativ kann auch ein Zeilenumbruch anstatt der Semikola eingefügt werden.
```julia; term=true
a = [1 2; 3 4]
b = [4 2
	 3 1]
```

Eine `mxn`-Matrix hat `m` Zeilen und `n` Spalten.
Mit der Syntax `matrix[m,n]` kann auf ein Element der Matrix zugegriffen werden.
Ebenso kann auf Teile der Matrix zugegriffen werden.
Ein Doppelpunkt `:` ohne Indizes bezeichnet dabei die gesamte Zeile oder Spalte.
```julia; term=true
m = rand(3,6)
m[2,3]
m[1:2,6]
m[3,:]
```

Die Funktion `rand` erzeugt Zufallszahlen in unterschiedlicher Art.
Ohne Argumente wirt eine einzelne Zufahlszahl zwischen 0 und 1 zurückgegeben.
Es können allerdings auch mehrere Int-Zahlen als Argumente übergeben werden.
Dabei gibt die erste Zahl die Anzahl der Elemente in erster Dimension, die zweite Zahl die Anzahl der Elemente in zweiter Dimension, usw. an.
`rand(3, 2, 4)` erzeugt also ein dreidimensionales `3x2x4`-Array voller Zufallszahlen zwischen 0 und 1.
```julia; term=true
rand()
rand(2)
rand(2,2)
rand(3,2,4)
```

### Broadcasting
Viele Operationen in Julia können elementweise aus Arrays angewendet werden.
Diese Vorgehensweise wird auch *Broadcasting* genannt.
Dazu wird bei Operatoren wie `+` und `^` ein `.` vorangestellt oder bei Funktionen ein `.` hinter dem Funktionsnamen angehängt:
```julia; term=true
a = [1 2 3; 3 4 5];
a .^2
a .+ 4
b = ["Tom" "Jerry"; "Michael" "John"];
length.(b)
```

## Tuple
Der Datentyp `Tuple` ist sehr ähnlich zum eindimensionalen Array.
Der wichtigste Unterschied ist, dass `Tuple` nicht veränderbar sind.
Am einfachsten wird ein Tuple durch die Eingabe von mehreren durch Kommas getrennte Werte erzeugt.
Übersichtlicher ist es aber, die Werte mit runden Klammern zu umgeben:
```julia;term=true
t1 = 1, 2, 3, 4
t2 = ('a', 'b', 'c')
```

Wie beim Array können auch unterschiedliche Datentypen in ein Tuple geschrieben werden.
Die Datentypen werden dabei im Datentypen des Tuples geschrieben:
```julia; term=true
t = (1, 3.1415, "foo", ('c',))
typeof(t)
```

Tuple mit nur einem Element müssen mit einem Komma abgeschlossen werden.
Ein leeres Tuple kann mittels `tuple()` erzeugt werden.
```julia; term=true
t1 = ('!',)
c = ('!')
t2 = tuple()
```

Wie bei Arrays kann mittels eckiger Klammern auf einzelne oder mehrere Elemente eines Tuples zugegriffen werden.
Da ein Tuple allerdings nicht veränderbar ist, gibt Julia bei Neudefinition eines Wertes einen *MethodError* zurück.
```
t = (2, 3, 5, 7, 11, 13, 17, 19)
print(t[3])
print(t[4:6])
print(t[5:end])
t[4] = 23
```

## Dict
Ein `Dict` ist ebenfalls sehr ähnlich zum eindimensionalen Array.
Während sich beim Array die Indizes auf Int-Zahlen beschränken, können die Indizes eines *Dictionaries* nahezu jeder Datentyp sein.
Die Indizes eines Dictionaries heißen *keys* und die Werte werden *values* genannt.
Jeder Wert ist dabei einem key zugewiesen.
it einem Dictionary kann zum Beispiel ein Wörterbuch erstellt werden, in dem jeder key ein deutsches Wort ist dem das passende spanische Wort zugeordnet ist.
Mit `Dict` wird ein Dictionary erstellt:
```julia; term=true
de2sp = Dict("eins" => "uno", "zwei" => "dos", "drei" => "tres")
```
Ein weiterer wichtiger Unterschied zu Arrays ist, dass Dictionaries nicht geordnet sind.
Es kann daher sein, dass die Elemente nicht in der eingegebenen Reihenfolge angezeigt werden.

Die Syntax für die Eingabe von key-value-Paaren ist dabei folgende:
  - ein key-value-Paar besteht aus dem key gefolgt von `=>` und dem zugehörigen Wert,
  - die einzelnen Einträge werden durch ein Komma getrennt.
Durch eckige Klammern und Eingabe eines Index kann auf die Werte zugegriffen werden.
Falls der eingegebene Index nicht im Dictionary vorhanden ist, gibt Julia einen *KeyError* zurück.
```julia; term=true
de2sp["zwei"]
de2sp["vier"]
```

Das sollte geändert werden.
Neue Indizes können auf folgende Weise hinzugefügt werden:
```julia; term=true
de2sp["vier"] = "cuatro"
print(de2sp)
```

Auf diese Weise können vorhandene Werte neu definiert werden.
Die Funktionen `keys` und `values` geben Arrays mit den keys oder values eines Dictionaries zurück.
```julia; term=true
keys(de2sp)
values(de2sp)
```

## Aufgaben
### Drei Arrays zusammenhängen
Schreibe eine Funktion `connect_three` die drei Arrays als Argumente nimmte und diese Arrays zu einem Array zusammenfügt.
Die Funktion muss nur für Arrays mit gleichem Datentypen funktionieren (z.B. dreimal Array{String,1} oder dreimal Array{Any,1}).
```julia
function connect_three(a,b,c)
	return append!(append!(a,b),c)
end
```
```julia;term=true
a = [1, 1, 2];
b = [3, 5];
c = [8, 13];
connect_three(a,b,c)
```

### Innere Werte eines Arrays
Schreibe eine Funktion `interior` die ein Array als Argument nimmt und ein neues Array zurückgibt, das alle Werte bis auf den ersten und  den letzten enthält.
```julia
function interior(a)
	return a[2:end-1]
end
```
```julia;term=true
a = [0,1,2,3,4];
res1 = interior(a)
res2 = interior(res1)
```

### Ist das Array sortiert?
Schreibe eine Funktion `issort` die ein Array als Argument nimmt, überprüft ob dieses Array sortiert ist und dementsprechend `true` oder `false` zurückgibt.
```julia
function issort(a)
	return a == sort(a)
end
```
```julia;term=true
a = [3,2,5,1];
b = sort(a);
issort(a)
issort(b)
```

### Anagram-Test
Schreibe eine Funktion `isanagram` die zwei Strings als Argumente nimmt, überprüft ob diese Strings Anagramme sind und dementsprechend `ture` oder `false` zurückgibt.
Groß- und Kleinschreibung soll dabei nicht berücksichtigt werden (`Stein` ist gleichwertig zu `stein`).
Zwei Wörter sind Anagramme, wenn die Buchstaben eines Wortes durch Umordnen das zweite Wort ergeben.
```julia
function isanagram(s1, s2)
	return sort(collect(lowercase(s1))) == sort(collect(lowercase(s2)))
end
```
```julia;term=true
isanagram("spam","eggs")
isanagram("Stein","niest")
```

### N-tes Element eines Dict ausgeben
Schreibe eine Funktion `dict_index(d,n)` die ein Dict `d` und eine Int-Zahl `n` als Argumente nimmt und das `n`-te Element dieses Dicts, sortiert nach den keys zurückgibt.
```julia
function dict_index(d, n)
	return d[sort(collect(keys(d)))[n]]
end
```
```julia;term=true
d = Dict("a"=>1,"b"=>2, "c"=>3, "d"=>4)
dict_index(d, 2)
```

### Dictionaries zusammenfügen
Schreibe eine Funktion `dict_merge` die zwei Dicts vom gleichen Typ als Argumente nimmt, diese beiden Dictionaries zusammenführt (merged) und als return value zurückgibt.
```julia
function dict_merge(d1, d2)
	k = collect(keys(d1))
	append!(k,collect(keys(d2)))
	v = collect(values(d1))
	append!(v,collect(values(d2)))
	return Dict(zip(k,v))
end
```
```julia;term=true
d1 = Dict("Hans"=>85.3,"Michael"=>74.9)
d2 = Dict("Lisa"=>56.1,"Anna"=>68.1)
dict_merge(d1, d2)
```

### Tuples zusammenfügen
Schreibe eine Funktion `tuple_append` die zwei Tuples als Argumente nimmt, das zweite an das erste anhängt und as zusammengefügte Tuple als return value zurückgibt.

