# Funktionen
In den vorhergehenden Kapiteln wurden schon einige Funktionen verwendet (z.B. `abs`, `typeof` oder `length`).
Eine Funktion wird durch ihren Namen, gefolgt von runden Klammern aufgerufen.
Innerhalb dieser runden Klammern stehen die *Argumente* der Funktion.
Vereinfacht lässt sich eine Funktion durch eine Box darstellen, der Werte (die Argumente) zugeführt werden.
Innerhalb der Box wird dann Code ausgeführt und oft am Ende ein Ergebnis (*return value*) zurückgegeben.
Der return value kann einfach einer Variable zugewiesen werden:
```julia; term=true
l = length("spam")
@show l
```
Während manche Funktionen keine Argumente benötigen, erfordern andere Funktionen mehrere Eingangswerte.
```julia; term=true
pwd()
length("banana")
```
`pwd` zeigt den aktuellen Arbeitspfad an (*print working directory*) und erfordert dabei keine Argumente.

Analog gibt es sowohl Funktionen die keinen *return value* zurückgeben, als auch Funktionen die mehrere Ergebnisse ausgeben.
```julia; term=true
p = println("Diese Zeile wird angezeigt, println weist p aber keinen Wert zu")
println(p)
a = [10,35,4,65,9];
maximum(a)
findmax(a)
```
Der erste Aufruf von `println` schreibt zwar das Übergebene Argument in der REPL, `println(p)` zeigt allerdings keinen Wert an.
Das liegt daran, dass `println` keinen return value an die Variable `p` übergibt (genau genommen gibt die Funktion einen Wert vom Typ `Nothing` zurück).
In der nächsten Zeile wird der Array `a` erstellt.
Auf Arrays wird später noch genauer eingegangen.
Während `maximum` nur den Maximalwert von `a` zurückgibt, ermittelt `findmax` zusätzlich die Stelle des Maximalwertes.

Die Argumente einer Funktion können verschiedenste Ausdrücke sein.
Sowohl Werte und Variablen, als auch Funktionen können als Argument übergeben werden.
Julia wertet diese Ausdrücke dann aus und übergibt das Ergebnis an die Funktion.
```julia; term=true
s1 = "foo";
s2 = "bar";
string(s1, s2)
round(20/9)
length(pwd())
```

Manchen Funktionen können sogenannte *keyword arguments* übergeben werden.
`round` ist beispielsweise eine solche Funktion.
Mit dem *keyword* `digits` gefolgt von `=` und einer Int-Zahl, kann die Anzahl der Nachkommastellen festgelegt werden.
```julia; term=true
round(2.3345323,digits=2)
```
Gerade bei Funktionen mit vielen (optionalen) Argumenten sind keyword arguments sehr hilfreich, da sie in beliebiger Reihenfolge an die Funktion übergeben werden können.

## Neue Funktionen erstellen

  - functions are good for faster and shorter code, especially with repetetive code
    - easier debugging
    - make changes in one place if the code repeats often
    - debug parts one at a time
    - reusable code
    - performance improvements
  - Adding new functions
    - function ... end
    - f(x) = ...
    - function names like variable names
    - empty brackets --> no arguments
    - indentation for readability
    - body of the function can contain any number of statements
  - flow of execution
  - Docstrings und Hilfe

https://docs.julialang.org/en/v1/manual/functions/

## Scope
  - global and local scope (variables and parameters)

## Methoden
  - Type System --> Supertypes und subtypes
    - small type tree
  - different behaviour of functions on different types
  - type declaration with `::`

## Aufgaben
### Schreibe funktionen für Berechnung von Kreis Fläche und Umfang
